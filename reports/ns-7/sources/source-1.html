


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>kotlin-mpp-playground Coverage Report > FFM</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: kotlin-mpp-playground<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">dev.suresh.lang</a>
</div>

<h1>Coverage Summary for Class: FFM (dev.suresh.lang)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">FFM</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/121)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/813)
  </span>
</td>
</tr>
  <tr>
    <td class="name">FFM$memoryLayout$$inlined$runOnVirtualThread$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/121)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/813)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package dev.suresh.lang
&nbsp;
&nbsp;import dev.suresh.*
&nbsp;import io.github.oshai.kotlinlogging.KLogger
&nbsp;import java.lang.foreign.*
&nbsp;import java.lang.invoke.MethodHandle
&nbsp;import java.lang.invoke.MethodHandles
&nbsp;import java.lang.invoke.MethodType
&nbsp;import java.time.Instant
&nbsp;
&nbsp;object FFM {
&nbsp;
&nbsp;  context(KLogger)
<b class="nc">&nbsp;  suspend fun memoryLayout() = runOnVirtualThread {</b>
&nbsp;    memoryAPIs()
&nbsp;    currTime()
&nbsp;    strlen(&quot;Hello Panama!&quot;)
&nbsp;    getPid()
&nbsp;    gmtime()
&nbsp;    terminal()
&nbsp;    dhReflection()
&nbsp;  }
&nbsp;
&nbsp;  context(KLogger)
&nbsp;  private fun strlen(str: String) {
<b class="nc">&nbsp;    val strlenAddr = SYMBOL_LOOKUP.findOrNull(&quot;strlen&quot;)</b>
<b class="nc">&nbsp;    val strlenDescriptor = FunctionDescriptor.of(ValueLayout.JAVA_INT, AddressLayout.ADDRESS)</b>
<b class="nc">&nbsp;    val strlen = LINKER.downcallHandle(strlenAddr, strlenDescriptor)</b>
<b class="nc">&nbsp;    Arena.ofConfined().use { arena -&gt;</b>
<b class="nc">&nbsp;      val cString = arena.allocateFrom(str)</b>
<b class="nc">&nbsp;      val strlenResult = strlen.invokeExact(cString) as Int</b>
<b class="nc">&nbsp;      info { &quot;&quot;&quot;strlen(&quot;$str&quot;) = $strlenResult&quot;&quot;&quot; }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  context(KLogger)
&nbsp;  private fun currTime() {
&nbsp;    // Print the current time.
<b class="nc">&nbsp;    val timeAddr = SYMBOL_LOOKUP.findOrNull(&quot;time&quot;)</b>
<b class="nc">&nbsp;    val timeDesc = FunctionDescriptor.of(ValueLayout.JAVA_LONG)</b>
<b class="nc">&nbsp;    val time = LINKER.downcallHandle(timeAddr, timeDesc)</b>
<b class="nc">&nbsp;    val timeResult = time.invokeExact() as Long</b>
<b class="nc">&nbsp;    info { &quot;time() = $timeResult epochSecond&quot; }</b>
&nbsp;  }
&nbsp;
&nbsp;  context(KLogger)
&nbsp;  private fun gmtime() {
<b class="nc">&nbsp;    val gmtAddr = SYMBOL_LOOKUP.findOrNull(&quot;gmtime&quot;)</b>
<b class="nc">&nbsp;    val gmtDesc =</b>
<b class="nc">&nbsp;        FunctionDescriptor.of(</b>
<b class="nc">&nbsp;            AddressLayout.ADDRESS.withTargetLayout(TM.LAYOUT), AddressLayout.ADDRESS)</b>
<b class="nc">&nbsp;    val gmtime = LINKER.downcallHandle(gmtAddr, gmtDesc)</b>
&nbsp;
<b class="nc">&nbsp;    Arena.ofConfined().use { arena -&gt;</b>
<b class="nc">&nbsp;      val time = arena.allocate(ValueLayout.JAVA_LONG.byteSize())</b>
<b class="nc">&nbsp;      time.set(ValueLayout.JAVA_LONG, 0, Instant.now().epochSecond)</b>
<b class="nc">&nbsp;      val tmSegment = gmtime.invokeExact(time) as MemorySegment</b>
<b class="nc">&nbsp;      info { &quot;gmtime() = ${TM(tmSegment)}&quot; }</b>
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  context(KLogger)
&nbsp;  private fun getPid() {
<b class="nc">&nbsp;    val getpidAddr = SYMBOL_LOOKUP.findOrNull(&quot;getpid&quot;)</b>
<b class="nc">&nbsp;    val getpidDesc = FunctionDescriptor.of(ValueLayout.JAVA_INT)</b>
<b class="nc">&nbsp;    val getpid = LINKER.downcallHandle(getpidAddr, getpidDesc)</b>
<b class="nc">&nbsp;    val pid = getpid.invokeExact() as Int</b>
<b class="nc">&nbsp;    assert(pid.toLong() == ProcessHandle.current().pid())</b>
<b class="nc">&nbsp;    info { &quot;getpid() = $pid&quot; }</b>
&nbsp;  }
&nbsp;
&nbsp;  /**
&nbsp;   * Allocate memory for two doubles and initialize it.
&nbsp;   *
&nbsp;   * ```c
&nbsp;   *  Struct Point2D {
&nbsp;   *    double x;
&nbsp;   *    double y;
&nbsp;   *  } point = { 1.0, 2.0 };
&nbsp;   * ```
&nbsp;   */
&nbsp;  context(KLogger)
&nbsp;  private fun memoryAPIs() {
<b class="nc">&nbsp;    Arena.ofConfined().use { arena -&gt;</b>
<b class="nc">&nbsp;      val point = arena.allocate(ValueLayout.JAVA_DOUBLE.byteSize() * 2)</b>
<b class="nc">&nbsp;      point.set(ValueLayout.JAVA_DOUBLE, 0, 1.0)</b>
<b class="nc">&nbsp;      point.set(ValueLayout.JAVA_DOUBLE, 8, 2.0)</b>
<b class="nc">&nbsp;      info { &quot;Point Struct = $point&quot; }</b>
<b class="nc">&nbsp;      info {</b>
&nbsp;        &quot;&quot;&quot;Struct {
<b class="nc">&nbsp;          |  x = ${point.get(ValueLayout.JAVA_DOUBLE, 0)} ,</b>
<b class="nc">&nbsp;          |  y = ${point.get(ValueLayout.JAVA_DOUBLE, 8)}</b>
&nbsp;          |}
&nbsp;         &quot;&quot;&quot;
<b class="nc">&nbsp;            .trimMargin()</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
<b class="nc">&nbsp;    val point2D =</b>
<b class="nc">&nbsp;        MemoryLayout.structLayout(</b>
<b class="nc">&nbsp;                ValueLayout.JAVA_DOUBLE.withName(&quot;x&quot;),</b>
<b class="nc">&nbsp;                ValueLayout.JAVA_DOUBLE.withName(&quot;y&quot;),</b>
&nbsp;            )
<b class="nc">&nbsp;            .withName(&quot;Point2D&quot;)</b>
&nbsp;
&nbsp;    // VarHandle accessors for the struct fields
<b class="nc">&nbsp;    val x = point2D.varHandle(MemoryLayout.PathElement.groupElement(&quot;x&quot;))</b>
<b class="nc">&nbsp;    val y = point2D.varHandle(MemoryLayout.PathElement.groupElement(&quot;y&quot;))</b>
&nbsp;
<b class="nc">&nbsp;    Arena.ofConfined().use { arena -&gt;</b>
&nbsp;      // val seg = MemorySegment.allocateNative(8,arena.scope())
<b class="nc">&nbsp;      val point = arena.allocate(point2D)</b>
<b class="nc">&nbsp;      x.set(point, 0L, 1.0)</b>
<b class="nc">&nbsp;      y.set(point, 0L, 2.0)</b>
<b class="nc">&nbsp;      info { &quot;Point2D segment = $point&quot; }</b>
<b class="nc">&nbsp;      info {</b>
&nbsp;        &quot;&quot;&quot;Point2D {
<b class="nc">&nbsp;          |  x = ${x.get(point, 0L)} ,</b>
<b class="nc">&nbsp;          |  y = ${y.get(point, 0L)}</b>
&nbsp;          |}&quot;&quot;&quot;
<b class="nc">&nbsp;            .trimMargin()</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    // Allocate an off-heap region of memory big enough to hold 10 values of the primitive type int,
&nbsp;    // and fill it with values ranging from 0 to 9
<b class="nc">&nbsp;    Arena.ofConfined().use { arena -&gt;</b>
<b class="nc">&nbsp;      val count = 10</b>
<b class="nc">&nbsp;      val segment = arena.allocate(count * ValueLayout.JAVA_INT.byteSize())</b>
<b class="nc">&nbsp;      for (i in 0 ..&lt; count) {</b>
<b class="nc">&nbsp;        segment.setAtIndex(ValueLayout.JAVA_INT, i.toLong(), i)</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;  }
&nbsp;
&nbsp;  context(KLogger)
&nbsp;  private fun terminal() {
<b class="nc">&nbsp;    val winsize =</b>
<b class="nc">&nbsp;        MemoryLayout.structLayout(</b>
<b class="nc">&nbsp;                ValueLayout.JAVA_SHORT.withName(&quot;ws_row&quot;),</b>
<b class="nc">&nbsp;                ValueLayout.JAVA_SHORT.withName(&quot;ws_col&quot;),</b>
<b class="nc">&nbsp;                ValueLayout.JAVA_SHORT.withName(&quot;ws_xpixel&quot;),</b>
<b class="nc">&nbsp;                ValueLayout.JAVA_SHORT.withName(&quot;ws_ypixel&quot;),</b>
&nbsp;            )
<b class="nc">&nbsp;            .withName(&quot;winsize&quot;)</b>
&nbsp;
<b class="nc">&nbsp;    val wsRow = winsize.varHandle(MemoryLayout.PathElement.groupElement(&quot;ws_row&quot;))</b>
<b class="nc">&nbsp;    val wsCol = winsize.varHandle(MemoryLayout.PathElement.groupElement(&quot;ws_col&quot;))</b>
<b class="nc">&nbsp;    val wsXpixel = winsize.varHandle(MemoryLayout.PathElement.groupElement(&quot;ws_xpixel&quot;))</b>
<b class="nc">&nbsp;    val wsYpixel = winsize.varHandle(MemoryLayout.PathElement.groupElement(&quot;ws_ypixel&quot;))</b>
&nbsp;
<b class="nc">&nbsp;    val ioctlFun =</b>
<b class="nc">&nbsp;        FunctionDescriptor.of(</b>
<b class="nc">&nbsp;            ValueLayout.JAVA_INT,</b>
<b class="nc">&nbsp;            ValueLayout.JAVA_INT,</b>
<b class="nc">&nbsp;            ValueLayout.JAVA_LONG,</b>
<b class="nc">&nbsp;            AddressLayout.ADDRESS.withTargetLayout(winsize))</b>
<b class="nc">&nbsp;    val isAttyFun = FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT)</b>
&nbsp;
&nbsp;    // For capturing the errno value
<b class="nc">&nbsp;    val ccs = Linker.Option.captureCallState(&quot;errno&quot;)</b>
<b class="nc">&nbsp;    val csLayout = Linker.Option.captureStateLayout()</b>
<b class="nc">&nbsp;    val errnoHandle = csLayout?.varHandle(MemoryLayout.PathElement.groupElement(&quot;errno&quot;))</b>
&nbsp;
<b class="nc">&nbsp;    val ioctl = downcallHandle(&quot;ioctl&quot;, ioctlFun, ccs, Linker.Option.firstVariadicArg(2))</b>
<b class="nc">&nbsp;    val isAtty = downcallHandle(&quot;isatty&quot;, isAttyFun)</b>
&nbsp;
<b class="nc">&nbsp;    Arena.ofConfined().use { arena -&gt;</b>
<b class="nc">&nbsp;      val isTerminal = isAtty?.invokeExact(1) as Int != 0</b>
<b class="nc">&nbsp;      if (isTerminal) {</b>
<b class="nc">&nbsp;        val winSeg = arena.allocate(winsize)</b>
<b class="nc">&nbsp;        val capturedState = arena.allocate(csLayout)</b>
<b class="nc">&nbsp;        val winRet = ioctl?.invokeExact(capturedState, 1, 0x40087468L, winSeg) as Int</b>
&nbsp;
<b class="nc">&nbsp;        if (winRet == -1) {</b>
<b class="nc">&nbsp;          val errno = errnoHandle?.get(capturedState, 0L) as Int</b>
<b class="nc">&nbsp;          info { &quot;ioctl() errno: $errno&quot; }</b>
&nbsp;        } else {
<b class="nc">&nbsp;          info {</b>
&nbsp;            &quot;&quot;&quot;
&nbsp;                |winsize {
<b class="nc">&nbsp;                |  ws_row = ${wsRow.get(winSeg, 0L)}</b>
<b class="nc">&nbsp;                |  ws_col = ${wsCol.get(winSeg, 0L)}</b>
<b class="nc">&nbsp;                |  ws_xpixel = ${wsXpixel.get(winSeg, 0L)}</b>
<b class="nc">&nbsp;                |  ws_ypixel = ${wsYpixel.get(winSeg, 0L)}</b>
&nbsp;                |}
&nbsp;                &quot;&quot;&quot;
<b class="nc">&nbsp;                .trimMargin()</b>
&nbsp;          }
&nbsp;        }
&nbsp;      } else {
<b class="nc">&nbsp;        info { &quot;Not a TTY&quot; }</b>
&nbsp;      }
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /** Atomic access for long[] using a MemorySegment */
&nbsp;    fun arrayAtomicAccess() {
<b class="nc">&nbsp;      val arr = LongArray(10)</b>
<b class="nc">&nbsp;      val arrSeg = MemorySegment.ofArray(arr)</b>
<b class="nc">&nbsp;      val vh = ValueLayout.JAVA_INT.varHandle()</b>
<b class="nc">&nbsp;      vh.setVolatile(arrSeg, 0L, 69)</b>
<b class="nc">&nbsp;      assert(vh.getVolatile(arrSeg, 0L) as Int == 69)</b>
&nbsp;    }
&nbsp;  }
&nbsp;
&nbsp;  /** Reflectively invoke the downcallHandle method on the Linker class. */
&nbsp;  context(KLogger)
&nbsp;  private fun dhReflection() {
<b class="nc">&nbsp;    val mh =</b>
<b class="nc">&nbsp;        MethodHandles.lookup()</b>
<b class="nc">&nbsp;            .findVirtual(</b>
<b class="nc">&nbsp;                Linker::class.java,</b>
<b class="nc">&nbsp;                &quot;downcallHandle&quot;,</b>
<b class="nc">&nbsp;                MethodType.methodType(</b>
<b class="nc">&nbsp;                    MethodHandle::class.java,</b>
<b class="nc">&nbsp;                    FunctionDescriptor::class.java,</b>
<b class="nc">&nbsp;                    Array&lt;Linker.Option&gt;::class.java,</b>
&nbsp;                ),
&nbsp;            )
<b class="nc">&nbsp;    val handle =</b>
<b class="nc">&nbsp;        mh.invokeExact(LINKER, FunctionDescriptor.ofVoid(), arrayOf&lt;Linker.Option&gt;())</b>
&nbsp;            as MethodHandle
<b class="nc">&nbsp;    info { &quot;Got downcall handle: $handle&quot; }</b>
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-22 05:04</div>
</div>
</body>
</html>
