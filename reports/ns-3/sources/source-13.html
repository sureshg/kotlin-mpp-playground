


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>: Coverage Report > Platform</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: :<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">dev.suresh</a>
</div>

<h1>Coverage Summary for Class: Platform (dev.suresh)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">Platform</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (6/9)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    92.5%
  </span>
  <span class="absValue">
    (37/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.8%
  </span>
  <span class="absValue">
    (247/269)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;package dev.suresh
&nbsp;
&nbsp;import com.sun.management.OperatingSystemMXBean
&nbsp;import java.io.File
&nbsp;import java.lang.invoke.MethodHandles
&nbsp;import java.lang.invoke.MethodType
&nbsp;import java.lang.management.ManagementFactory
&nbsp;import java.net.InetAddress
&nbsp;import java.net.InetSocketAddress
&nbsp;import java.net.Socket
&nbsp;import java.net.StandardSocketOptions
&nbsp;import java.nio.charset.Charset
&nbsp;import java.security.KeyStore
&nbsp;import java.security.Security
&nbsp;import java.time.Duration
&nbsp;import java.time.Instant
&nbsp;import java.time.LocalDateTime
&nbsp;import java.time.ZoneId
&nbsp;import java.time.format.DateTimeFormatter
&nbsp;import java.util.*
&nbsp;import java.util.concurrent.ExecutorService
&nbsp;import java.util.concurrent.Executors
<b class="nc">&nbsp;import javax.net.ssl.TrustManagerFactory</b>
&nbsp;import javax.net.ssl.X509TrustManager
&nbsp;import kotlinx.coroutines.*
<b class="nc">&nbsp;import org.slf4j.LoggerFactory</b>
&nbsp;
&nbsp;actual val platform: Platform = JvmPlatform
<b class="fc">&nbsp;</b>
&nbsp;object JvmPlatform : Platform {
&nbsp;
&nbsp;  private val log = LoggerFactory.getLogger(this::class.java)
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;  override val name: String = &quot;JVM&quot;</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;  override fun env(key: String, def: String?): String? = System.getenv(key) ?: def</b>
&nbsp;
&nbsp;  override fun sysProp(key: String, def: String?): String? = System.getProperty(key, def)
&nbsp;
<b class="fc">&nbsp;  override val tzShortId: String</b>
&nbsp;    get() {
&nbsp;      // ZoneId.systemDefault().getDisplayName(TextStyle.SHORT_STANDALONE, Locale.ENGLISH)
&nbsp;      return DateTimeFormatter.ofPattern(&quot;zzz&quot;)
<b class="fc">&nbsp;          .withLocale(Locale.ENGLISH)</b>
<b class="fc">&nbsp;          .withZone(ZoneId.systemDefault())</b>
<b class="fc">&nbsp;          .format(Instant.now())</b>
<b class="fc">&nbsp;    }</b>
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;  /** A coroutine dispatcher that executes tasks on Virtual Threads. */</b>
<b class="fc">&nbsp;  override val virtualDispatcher: CoroutineDispatcher by lazy {</b>
<b class="fc">&nbsp;    log.info(&quot;Creating CoroutineDispatcher based on Java VirtualThreadPerTaskExecutor...&quot;)</b>
<b class="fc">&nbsp;    // Executors.newVirtualThreadPerTaskExecutor().asCoroutineDispatcher()</b>
<b class="fc">&nbsp;    val mh =</b>
<b class="fc">&nbsp;        MethodHandles.publicLookup()</b>
<b class="fc">&nbsp;            .findStatic(</b>
<b class="fc">&nbsp;                Executors::class.java,</b>
<b class="fc">&nbsp;                &quot;newVirtualThreadPerTaskExecutor&quot;,</b>
<b class="fc">&nbsp;                MethodType.methodType(</b>
<b class="fc">&nbsp;                    ExecutorService::class.java,</b>
<b class="fc">&nbsp;                ))</b>
<b class="fc">&nbsp;    val execService = mh.invokeExact() as ExecutorService</b>
<b class="fc">&nbsp;    execService.asCoroutineDispatcher()</b>
<b class="fc">&nbsp;    // Via Reflection</b>
<b class="fc">&nbsp;    // (Executors::class.java.getMethod(&quot;newVirtualThreadPerTaskExecutor&quot;).invoke(null) as</b>
<b class="fc">&nbsp;    // ExecutorService).asCoroutineDispatcher()</b>
&nbsp;  }
<b class="fc">&nbsp;</b>
<b class="fc">&nbsp;  override val appInfo: Map&lt;String, String&gt;</b>
<b class="fc">&nbsp;    get() =</b>
<b class="fc">&nbsp;        super.appInfo +</b>
<b class="fc">&nbsp;            mapOf(</b>
<b class="fc">&nbsp;                &quot;uptime&quot; to</b>
<b class="fc">&nbsp;                    run {</b>
&nbsp;                      val processEpochSec =
&nbsp;                          ProcessHandle.current().info().startInstant().get().epochSecond
<b class="nc">&nbsp;                      epochSecToString(processEpochSec)</b>
&nbsp;                    })
<b class="fc">&nbsp;</b>
&nbsp;  override val osInfo: Map&lt;String, String?&gt;
&nbsp;    get() =
<b class="fc">&nbsp;        super.osInfo +</b>
&nbsp;            mapOf(
&nbsp;                &quot;name&quot; to sysProp(&quot;os.name&quot;),
&nbsp;                &quot;version&quot; to sysProp(&quot;os.version&quot;),
&nbsp;                &quot;arch&quot; to sysProp(&quot;os.arch&quot;),
&nbsp;                &quot;user&quot; to sysProp(&quot;user.name&quot;),
&nbsp;            )
&nbsp;}
&nbsp;
&nbsp;val Dispatchers.Virtual
&nbsp;  get() = platform.virtualDispatcher
&nbsp;
&nbsp;/**
&nbsp; * Runs the given suspend block on [Dispatchers.Virtual], so that we can call blocking I/O APIs from
&nbsp; * coroutines
&nbsp; */
&nbsp;suspend inline fun &lt;T&gt; runOnVirtualThread(crossinline block: suspend CoroutineScope.() -&gt; T): T =
&nbsp;    withContext(Dispatchers.Virtual) { block() }
&nbsp;
&nbsp;/** Creates a new coroutine scope that uses [Dispatchers.Virtual] as its dispatcher. */
&nbsp;val virtualThreadScope
&nbsp;  get() = CoroutineScope(Dispatchers.Virtual)
&nbsp;
&nbsp;/** Returns the runtime information of the JVM and OS. */
&nbsp;fun jvmRuntimeInfo(debug: Boolean = false) = buildString {
&nbsp;  val rt = Runtime.getRuntime()
&nbsp;  val unit = 1024 * 1024L
&nbsp;  val heapSize = rt.totalMemory()
&nbsp;  val heapFreeSize = rt.freeMemory()
&nbsp;  val heapUsedSize = heapSize - heapFreeSize
&nbsp;  val heapMaxSize = rt.maxMemory()
&nbsp;  val osMxBean = ManagementFactory.getPlatformMXBean(OperatingSystemMXBean::class.java)
&nbsp;  val rtMxBean = ManagementFactory.getRuntimeMXBean()
&nbsp;
&nbsp;  appendLine(&quot;✧✧✧ Time: ${LocalDateTime.now()}&quot;)
&nbsp;  appendLine(&quot;✧✧✧ [JVM] JVM Version              : ${System.getProperty(&quot;java.version&quot;)}&quot;)
&nbsp;
&nbsp;  appendLine(&quot;✧✧✧ [SYS-OS]  Operating System     : ${System.getProperty(&quot;os.name&quot;)}&quot;)
&nbsp;  appendLine(&quot;✧✧✧ [SYS-CPU] CPU Arch             : ${System.getProperty(&quot;os.arch&quot;)}&quot;)
&nbsp;  appendLine(&quot;✧✧✧ [SYS-CPU] Available Processors : ${rt.availableProcessors()}&quot;)
&nbsp;  appendLine(&quot;✧✧✧ [SYS-CPU] System CPU Usage     : ${osMxBean.cpuLoad}&quot;)
&nbsp;  appendLine(&quot;✧✧✧ [JVM-CPU] JVM CPU Usage        : ${osMxBean.processCpuLoad}&quot;)
&nbsp;  appendLine(
&nbsp;      &quot;✧✧✧ [JVM-CPU] JVM CPU Time(Sec)    : ${Duration.ofNanos(osMxBean.processCpuTime).toSeconds()}&quot;)
&nbsp;  appendLine(&quot;✧✧✧ [SYS-MEM] Total Memory                  : ${osMxBean.totalMemorySize / unit} MiB&quot;)
&nbsp;  appendLine(&quot;✧✧✧ [SYS-MEM] Free  Memory                  : ${osMxBean.freeMemorySize / unit} MiB&quot;)
&nbsp;  appendLine(&quot;✧✧✧ [JVM-MEM] Current Heap Size (Committed) : ${heapSize / unit} MiB&quot;)
&nbsp;  appendLine(&quot;✧✧✧ [JVM-MEM] Current Free memory in Heap   : ${heapFreeSize/unit} MiB&quot;)
&nbsp;  appendLine(&quot;✧✧✧ [JVM-MEM] Currently used memory         : ${heapUsedSize/unit} MiB&quot;)
&nbsp;  appendLine(&quot;✧✧✧ [JVM-MEM] Max Heap Size (-Xmx)          : ${heapMaxSize/unit} MiB&quot;)
&nbsp;
&nbsp;  appendLine(&quot;✧✧✧ JVM Input Arguments ✧✧✧&quot;)
&nbsp;  appendLine(rtMxBean.inputArguments)
&nbsp;  appendLine(&quot;✧✧✧ JVM Main class &amp; Args ✧✧✧&quot;)
&nbsp;  appendLine(System.getProperty(&quot;sun.java.command&quot;))
&nbsp;
&nbsp;  appendLine(&quot;✧✧✧ Processes ✧✧✧&quot;)
&nbsp;  val ps = ProcessHandle.allProcesses().sorted(ProcessHandle::compareTo).toList()
&nbsp;  if (debug) {
&nbsp;    ps.forEach { appendLine(&quot;${it.pid()} : ${it.info()}&quot;) }
&nbsp;  } else {
&nbsp;    appendLine(&quot;Found ${ps.size} processes.&quot;)
&nbsp;  }
&nbsp;
&nbsp;  appendLine(&quot;✧✧✧ Trust stores ✧✧✧&quot;)
&nbsp;  val caCerts =
&nbsp;      TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()).run {
&nbsp;        init(null as KeyStore?)
&nbsp;        trustManagers.filterIsInstance&lt;X509TrustManager&gt;().flatMap { it.acceptedIssuers.toList() }
&nbsp;      }
&nbsp;  caCerts.forEach { appendLine(it.issuerX500Principal) }
&nbsp;
&nbsp;  appendLine(&quot;✧✧✧ Dns Resolution ✧✧✧&quot;)
&nbsp;  val dns = InetAddress.getAllByName(&quot;google.com&quot;).toList()
&nbsp;  dns.forEach { appendLine(it) }
&nbsp;
&nbsp;  appendLine(&quot;✧✧✧ TimeZones ✧✧✧&quot;)
&nbsp;  val tz = ZoneId.getAvailableZoneIds()
&nbsp;  if (debug) {
&nbsp;    tz.forEach { appendLine(it) }
&nbsp;  } else {
&nbsp;    appendLine(&quot;Found ${tz.size} timezones.&quot;)
&nbsp;  }
&nbsp;
&nbsp;  appendLine(&quot;✧✧✧ Charsets ✧✧✧&quot;)
&nbsp;  val cs = Charset.availableCharsets()
&nbsp;  if (debug) {
&nbsp;    cs.forEach { (name, charset) -&gt; appendLine(&quot;$name: $charset&quot;) }
&nbsp;  } else {
&nbsp;    appendLine(&quot;Found ${cs.size} charsets.&quot;)
&nbsp;  }
&nbsp;
&nbsp;  appendLine(&quot;✧✧✧ System Locales ✧✧✧&quot;)
&nbsp;  val locales = Locale.getAvailableLocales()
&nbsp;  if (debug) {
&nbsp;    locales.forEach { appendLine(it) }
&nbsp;  } else {
&nbsp;    appendLine(&quot;Found ${locales.size} locales.&quot;)
&nbsp;  }
&nbsp;
&nbsp;  appendLine(&quot;✧✧✧ System Countries ✧✧✧&quot;)
&nbsp;  val countries = Locale.getISOCountries()
&nbsp;  if (debug) {
&nbsp;    countries.forEach { appendLine(it) }
&nbsp;  } else {
&nbsp;    appendLine(&quot;Found ${countries.size} countries.&quot;)
&nbsp;  }
&nbsp;
&nbsp;  appendLine(&quot;✧✧✧ System Currencies ✧✧✧&quot;)
&nbsp;  val currencies = Currency.getAvailableCurrencies()
&nbsp;  if (debug) {
&nbsp;    currencies.forEach { appendLine(it) }
&nbsp;  } else {
&nbsp;    appendLine(&quot;Found ${currencies.size} currencies.&quot;)
&nbsp;  }
&nbsp;
&nbsp;  appendLine(&quot;✧✧✧ System Languages ✧✧✧&quot;)
&nbsp;  val languages = Locale.getISOLanguages()
&nbsp;  if (debug) {
&nbsp;    languages.forEach { appendLine(it) }
&nbsp;  } else {
&nbsp;    appendLine(&quot;Found ${languages.size} languages.&quot;)
&nbsp;  }
&nbsp;
&nbsp;  appendLine(&quot;✧✧✧ Env Variables ✧✧✧&quot;)
&nbsp;  val env = System.getenv()
&nbsp;  env.forEach { (k: String, v: String) -&gt; appendLine(&quot;$k : $v&quot;) }
&nbsp;
&nbsp;  appendLine(&quot;✧✧✧ System Properties ✧✧✧&quot;)
&nbsp;  val props = System.getProperties()
&nbsp;  props.forEach { k: Any, v: Any -&gt; appendLine(&quot;$k : $v&quot;) }
&nbsp;
&nbsp;  val fmt = HexFormat.ofDelimiter(&quot;, &quot;).withUpperCase().withPrefix(&quot;0x&quot;)
&nbsp;  appendLine(&quot;✧✧✧ I ❤️ Kotlin = ${fmt.formatHex(&quot;I ❤️ Kotlin&quot;.encodeToByteArray())}&quot;)
&nbsp;  appendLine(&quot;✧✧✧ LineSeparator  = ${fmt.formatHex(System.lineSeparator().encodeToByteArray())}&quot;)
&nbsp;  appendLine(&quot;✧✧✧ File PathSeparator = ${fmt.formatHex(File.pathSeparator.encodeToByteArray())}&quot;)
&nbsp;  appendLine(&quot;✧✧✧ File Separator = ${fmt.formatHex(File.separator.encodeToByteArray())}&quot;)
&nbsp;
&nbsp;  appendLine(&quot;✧✧✧ Additional info in exception ✧✧✧&quot;)
&nbsp;  val ex =
&nbsp;      runCatching {
&nbsp;            Security.setProperty(&quot;jdk.includeInExceptions&quot;, &quot;hostInfo,jar&quot;)
&nbsp;            Socket().use { s -&gt;
&nbsp;              s.setOption(StandardSocketOptions.SO_REUSEADDR, true)
&nbsp;              s.setOption(StandardSocketOptions.SO_REUSEPORT, true)
&nbsp;              s.setOption(StandardSocketOptions.SO_KEEPALIVE, true)
&nbsp;              // Disable the Nagle algorithm as using it would hurt latency.
&nbsp;              s.setOption(StandardSocketOptions.TCP_NODELAY, true)
&nbsp;              // s.setOption(StandardSocketOptions.SO_RCVBUF, 4096)
&nbsp;              s.soTimeout = 100
&nbsp;              s.connect(InetSocketAddress(&quot;localhost&quot;, 12345), 10)
&nbsp;            }
&nbsp;          }
&nbsp;          .exceptionOrNull()
&nbsp;  appendLine(ex?.message)
&nbsp;  // check(ex?.message?.contains(&quot;localhost/127.0.0.1:12345&quot;) == true)
&nbsp;
&nbsp;  appendLine(
&nbsp;      &quot;&quot;&quot;
&nbsp;      +---------Summary-------+
&nbsp;      | Processes      : ${ps.size.toString().padEnd(5)}|
&nbsp;      | Dns Addresses  : ${dns.size.toString().padEnd(5)}|
&nbsp;      | Trust Stores   : ${caCerts.size.toString().padEnd(5)}|
&nbsp;      | TimeZones      : ${tz.size.toString().padEnd(5)}|
&nbsp;      | CharSets       : ${cs.size.toString().padEnd(5)}|
&nbsp;      | Locales        : ${locales.size.toString().padEnd(5)}|
&nbsp;      | Countries      : ${countries.size.toString().padEnd(5)}|
&nbsp;      | Languages      : ${languages.size.toString().padEnd(5)}|
&nbsp;      | Currencies     : ${currencies.size.toString().padEnd(5)}|
&nbsp;      | Env Vars       : ${env.size.toString().padEnd(5)}|
&nbsp;      | Sys Props      : ${props.size.toString().padEnd(5)}|
&nbsp;      | Virtual Thread : ${Thread.currentThread().isVirtual}|
&nbsp;      +-----------------------+
&nbsp;     &quot;&quot;&quot;
&nbsp;          .trimIndent(),
&nbsp;  )
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2025-04-07 01:56</div>
</div>
</body>
</html>
